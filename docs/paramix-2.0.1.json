{"(metadata)":{"source":["PROFILE"],"authors":[{"name":"Thomas Sawyer","email":"transfire@gmail.com"}],"copyrights":[{"holder":"Thomas Sawyer","year":"2006","license":"BSD-2-Clause"}],"replacements":[],"alternatives":[],"requirements":[{"name":"detroit","groups":["build"],"development":true},{"name":"qed","groups":["test"],"development":true}],"dependencies":[],"conflicts":[],"repositories":[],"resources":{"home":"http://rubyworks.github.com/paramix","code":"http://github.com/rubyworks/paramix","repo":"git://github.com/rubyworks/paramix.git"},"extra":{},"load_path":["lib"],"revision":0,"title":"Paramix","summary":"Parametric Mixins","description":"Parametric Mixins provides parameters for mixin modules.","organization":"RubyWorks","created":"2006-01-01","name":"paramix","version":"2.0.1","date":"2011-10-22","path":"(metadata)","markup":"rdoc"},"Paramix":{"!":"module","path":"Paramix","name":"Paramix","namespace":"","comment":"Paramix namespace.","format":"rdoc","constants":["Paramix::VERSION"],"includes":[],"extensions":[],"modules":["Paramix::Parametric"],"classes":[],"methods":[],"accessors":[],"files":["/lib/paramix.rb","/lib/paramix/version.rb"],"tags":{}},"Paramix::VERSION":{"!":"constant","path":"Paramix::VERSION","name":"VERSION","namespace":"Paramix","comment":":erb: VERSION = \"<%= version %>\"","format":"rdoc","value":"\"2.0.0\"","tags":{},"files":["/lib/paramix/version.rb"]},"Paramix::Parametric":{"!":"module","path":"Paramix::Parametric","name":"Parametric","namespace":"Paramix","comment":"= Parametric\n\nParametric mixins provides parameters for mixin modules.\nModule parameters can be set at the time of inclusion \nor extension using Module#[] method, then parameters\ncan be accessed via the #mixin_parameters method.\n\n  module MyMixin\n    include Paramix::Parametric\n\n    parameterized |params|\n      define_method :hello do\n        puts \"Hello from #{params[:name]}!\"\n      end\n    end\n  end\n\n  class MyClass\n    include MyMixin[:name => 'Ruby']\n  end\n\n  MyClass.new.hello   #=> 'Hello from Ruby!'","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":["Paramix::Parametric::Extensions"],"classes":["Paramix::Parametric::Mixin"],"methods":["Paramix::Parametric.included"],"accessors":[],"files":["/lib/paramix.rb"],"tags":{}},"Paramix::Parametric.included":{"!":"method","declarations":["class","public"],"path":"Paramix::Parametric.included","name":"included","namespace":"Paramix::Parametric","comment":"","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"included(.)","arguments":[{"name":"base"}]}],"returns":[],"file":"/lib/paramix.rb","line":37,"source":"def self.included(base)\n  base.extend(Extensions)\nend","language":"ruby","dynamic":true,"tags":{"private":null}},"Paramix::Parametric::Extensions":{"!":"module","path":"Paramix::Parametric::Extensions","name":"Extensions","namespace":"Paramix::Parametric","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Paramix::Parametric::Extensions#[]","Paramix::Parametric::Extensions#parameterized","Paramix::Parametric::Extensions#append_features","Paramix::Parametric::Extensions#extend_object"],"accessors":[],"files":["/lib/paramix.rb"],"tags":{}},"Paramix::Parametric::Extensions#[]":{"!":"method","declarations":["instance","public"],"path":"Paramix::Parametric::Extensions#[]","name":"[]","namespace":"Paramix::Parametric::Extensions","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"[](parameters={})","arguments":[{"name":"parameters","default":"{}"}]}],"returns":[],"file":"/lib/paramix.rb","line":44,"source":"def [](parameters={})\n  Mixin.new(self, parameters)\nend","language":"ruby","dynamic":true,"tags":{}},"Paramix::Parametric::Extensions#parameterized":{"!":"method","declarations":["instance","public"],"path":"Paramix::Parametric::Extensions#parameterized","name":"parameterized","namespace":"Paramix::Parametric::Extensions","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"parameterized(&code)","arguments":[],"block":{"name":"&code"}}],"returns":[],"file":"/lib/paramix.rb","line":49,"source":"def parameterized(&code)\n  @code ||= []\n  if block_given?\n    @code << code\n  else\n    @code\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"Paramix::Parametric::Extensions#append_features":{"!":"method","declarations":["instance","public"],"path":"Paramix::Parametric::Extensions#append_features","name":"append_features","namespace":"Paramix::Parametric::Extensions","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"append_features(base)","arguments":[{"name":"base"}]}],"returns":[],"file":"/lib/paramix.rb","line":58,"source":"def append_features(base)\n  return super(base) if Mixin === base || Mixin === self\n\n  base.extend(Extensions)\n\n  anc = ancestors.find{ |a| a.respond_to?(:parameterized) }\n  base.parameterized.concat(anc.parameterized)\n\n  super(base)\nend","language":"ruby","dynamic":true,"tags":{}},"Paramix::Parametric::Extensions#extend_object":{"!":"method","declarations":["instance","public"],"path":"Paramix::Parametric::Extensions#extend_object","name":"extend_object","namespace":"Paramix::Parametric::Extensions","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"extend_object(base)","arguments":[{"name":"base"}]}],"returns":[],"file":"/lib/paramix.rb","line":70,"source":"def extend_object(base)\n  return super(base) if Mixin === base || Mixin === self\n\n  base.extend(Extensions)\n\n  anc = ancestors.find{ |a| a.respond_to?(:parameterized) }\n  base.parameterized.concat(anc.parameterized)\n\n  super(base)\nend","language":"ruby","dynamic":true,"tags":{}},"Paramix::Parametric::Mixin":{"!":"class","superclass":"Module","path":"Paramix::Parametric::Mixin","name":"Mixin","namespace":"Paramix::Parametric","comment":"An instance of the Mixin module class is what is porduced\nwhen parameters are applied to a parametric module.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Paramix::Parametric::Mixin#initialize","Paramix::Parametric::Mixin#public","Paramix::Parametric::Mixin#private","Paramix::Parametric::Mixin#protected"],"accessors":[],"files":["/lib/paramix.rb"],"tags":{}},"Paramix::Parametric::Mixin#initialize":{"!":"method","declarations":["instance","public"],"path":"Paramix::Parametric::Mixin#initialize","name":"initialize","namespace":"Paramix::Parametric::Mixin","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(base, parameters)","arguments":[{"name":"base"},{"name":"parameters"}]}],"returns":[{"type":"Mixin","comment":"a new instance of Mixin"}],"file":"/lib/paramix.rb","line":88,"source":"def initialize(base, parameters)\n  include(base)\n  #base.append_features(self)\n  base.parameterized.each do |code|\n    instance_exec(parameters, &code)\n  end\n  #base.parameterized.clear\nend","language":"ruby","dynamic":true,"tags":{}},"Paramix::Parametric::Mixin#public":{"!":"method","declarations":["instance","public"],"path":"Paramix::Parametric::Mixin#public","name":"public","namespace":"Paramix::Parametric::Mixin","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"public(name, &code)","arguments":[{"name":"name"}],"block":{"name":"&code"}}],"returns":[],"file":"/lib/paramix.rb","line":98,"source":"def public(name, &code)\n  define_method(name, &code)\n  super(name)\nend","language":"ruby","dynamic":true,"tags":{}},"Paramix::Parametric::Mixin#private":{"!":"method","declarations":["instance","public"],"path":"Paramix::Parametric::Mixin#private","name":"private","namespace":"Paramix::Parametric::Mixin","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"private(name, &code)","arguments":[{"name":"name"}],"block":{"name":"&code"}}],"returns":[],"file":"/lib/paramix.rb","line":104,"source":"def private(name, &code)\n  define_method(name, &code)\n  super(name)\nend","language":"ruby","dynamic":true,"tags":{}},"Paramix::Parametric::Mixin#protected":{"!":"method","declarations":["instance","public"],"path":"Paramix::Parametric::Mixin#protected","name":"protected","namespace":"Paramix::Parametric::Mixin","comment":"","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"protected(name, &code)","arguments":[{"name":"name"}],"block":{"name":"&code"}}],"returns":[],"file":"/lib/paramix.rb","line":110,"source":"def protected(name, &code)\n  define_method(name, &code)\n  super(name)\nend","language":"ruby","dynamic":true,"tags":{}},"/README.md":{"!":"document","path":"README.md","name":"README.md","mtime":"2011-10-22 21:25:36 -0400","text":"# Paramix\n\n| Project    | Paramix                             |\n|:-----------|:------------------------------------|\n| Copyright  | (c) 2006 Rubyworks                  |\n| License    | BSD-2-Clause                        |\n| Website    | http://rubyworks.github.com/paramix |\n| GitHub     | http://github.com/rubyworks/paramix |\n| Status     | [![Build Status](https://secure.travis-ci.org/rubyworks/paramix.png)](http://travis-ci.org/rubyworks/paramix) |\n\n## Description\n\nParametric Mixins provides an easy means to \"functionalize\" modules.\nThe module can then be differentiated upon usage according to the\nparameters provided.\n\n\n## Release Notes\n\nPlease see the HISTORY.rdoc file.\n\n\n## Example\n\nHere is a simple example that uses a a parameter \nto define a method and another parameter to define\nit's return value.\n\n    module M\n      include Paramix::Parametric\n\n      paramaterized do |params|\n        define_method params[:name] do\n          params[:value]\n        end\n      end\n    end\n\n    class X\n      include M[:name=>'foo', :value='bar']\n    end\n\n    X.new.foo  #=> 'bar'\n\n\n## Copyrights\n\nCopyright (c) 2006 Thomas Sawyer\n\nThis program is ditributed unser the terms of the BSD-2-Clause license.\n\nSee COPYING.rdoc file for details.\n\n","format":"text/markdown"},"/HISTORY.rdoc":{"!":"document","path":"HISTORY.rdoc","name":"HISTORY.rdoc","mtime":"2011-10-22 21:25:36 -0400","text":"= RELEASE HISTORY\n\n== 2.0.1 // 2011-10-22\n\nThis release simply brings the project uptodate with the latest\nbuild tools, and switches the license to BSD-2-Clause.\n\nChanges:\n\n* Modernize build configuration.\n* Switch to FreeBSD license.\n\n\n== 2.0.0 // 2010-04-06\n\nThanks to a conversation with Jonathan Rochkind, Paramix has\nbeen completely rewritten.  Whereas anonymous modules were\navoided in prior versions, it has become clear that the worries\nof memory consumption that would accompany them were largely \nunfounded. This new version therefore makes use of them.\nThe new code is refreshingly concise, and the design fully\ncomforming to POLS.\n\nChanges:\n\n* Use anonymous modules instead of global parameter stores.\n* Use paramterized block for dynamic definitions.\n\n\n== 1.1.0 // 2010-04-05\n\nThe previous versions did not properly support nested parametric\nincludes, i.e. including one parametirc mixin into another. This\nrelease fixed this issue. However, to do so provided difficult\nand required some changes to the API. In particular, instead\nof +mixin_params[M][:p]+ one must now use +mixin_param(M,:p)+.\nIt was not longer possible to simply return a hash, since special\nlookup logic is required to handle nested mixins. It should also\nbe noted that +Module#mixin_parameters+, which stores the actual\nparameters is no longer accessible at the instance level, just\nas +mixin_param()+ is soley an instance method (at the class level\nit is used to access the singleton parameters).\n\nChanges:\n\n* Proper support for nested parametric mixins.\n* Provide #mixin_param method to lookup parameters.\n* The mixin_parameters method is class-level only.\n\n\n== 1.0.1 // 2010-04-03\n\nThis release simply removed dependencies on Facets.\n\nChanges:\n\n* Removed dependencies on Facets module/basename and module/modspace.\n* Divided tests into separate files.\n\n\n== 1.0.0 // 2009-06-29\n\nThis is the initial stand-alone release of Paramix spun-off\nfrom Ruby Facets (and is actually he second major version, the\noriginal being spun of from the Nitro/Og Glue library).\n\nChanges:\n\n* Happy Birthday!\n\n","format":"text/rdoc"},"/QED.rdoc":{"!":"document","path":"QED.rdoc","name":"QED.rdoc","mtime":"2011-10-22 21:27:41 -0400","text":"= Basic Example\n\nRequire the library.\n\n  require 'paramix'\n\nCreate a parametric mixin.\n\n    module MyMixin\n      include Paramix::Parametric\n\n      parameterized do |params|\n\n        public params[:name] do\n          params[:value]\n        end\n\n      end\n    end\n\nCreate a class that uses the mixin and set the parameter.\n\n    class X\n      include MyMixin[:name => 'f', :value=>1]\n    end\n\nThen the parameter is accessible.\n\n    X.new.f.assert == 1\n\n\n= Nested Parematric Mixins\n\nIf we create another parametric mixin which depends on the first.\n\n    module AnotherMixin\n      include Paramix::Parametric\n      include MyMixin[:name => 'f', :value=>1]\n\n      parameterized do |params|\n\n        public params[:name] do\n          params[:value]\n        end\n\n      end\n    end\n\nAnd a class for it.\n\n    class Y\n      include AnotherMixin[:name => 'g', :value=>2]\n    end\n\nWe can see that the parameters stay with their respective mixins.\n\n    Y.new.f.assert == 1\n    Y.new.g.assert == 2\n\nHowever if we do the same, but do not paramterize the first module then\nthe including module also become parametric.\n\n    module ThirdMixin\n      #include Paramix::Parametric\n      include MyMixin\n\n      parameterized do |params|\n\n        public params[:name].succ do\n          params[:value]\n        end\n\n      end\n    end\n\nAnd a class for it.\n\n    class Z\n      include ThirdMixin[:name => 'q', :value=>3]\n    end\n\nWe can see that the value of the parameter has propogated up to its\nancestor parametric module.\n\n    Z.new.q.assert == 3\n    Z.new.r.assert == 3\n\n\n= Parametric Include\n\nLoad the library.\n\n  require 'paramix'\n\nGiven a parametric mixin.\n\n  module M\n    include Paramix::Parametric\n\n    parameterized do |params|\n\n      public :f do\n        params[:p]\n      end\n\n    end\n  end\n\nWe can inlcude the parameteric module in a some classes.\n\n  class I1\n    include M[:p => \"mosh\"]\n  end\n\n  class I2\n    include M[:p => \"many\"]\n  end\n\nAnd the result will vary according to the parameter set.\n\n  I1.new.f  #=> \"mosh\"\n  I2.new.f  #=> \"many\"\n\n\n= Parametric Extension\n\nWe can also extend classes witht the mixin.\n\n  class E1\n    extend M[:p => \"mosh2\"]\n  end\n\n  class E2\n    extend M[:p => \"many2\"]\n  end\n\nAnd the results will likewise work as expected.\n\n   E1.f  #=> \"mosh2\"\n   E2.f  #=> \"many2\"\n\n\n= Dynamically Defined Methods\n\nParametric mixins can be used to define dynamic code.\n\n  module N\n    include Paramix::Parametric\n\n    parameterized do |params|\n      attr_accessor params[:a]\n    end\n  end\n\nNow if we include this module we will have new attributes based on\nthe parameter assigned.\n\n  class D1\n    include N[:a => \"m1\"]\n  end\n\n  class D2\n    include N[:a => \"m2\"]\n  end\n\n  d1 = D1.new\n  d1.m1 = :yes1\n\n  d1.m1  #=> :yes1\n\n  d2 = D2.new\n  d2.m2 = :yes2\n\n  d2.m2  #=> :yes2\n\n\n= Works with Namespaces\n\nParametric mixins work regardless of the namespace depth.\n\n  module R\n    module M\n      include Paramix::Parametric\n\n      parameterized do |params|\n        public :f do\n          params[:p]\n        end\n      end\n    end\n  end\n\n  module Q\n    class I\n      include R::M[:p => \"mosh\"]\n    end\n    class E\n      extend R::M[:p => \"many\"]\n    end\n  end\n\n  Q::I.new.f  #=> \"mosh\"\n\n  Q::E.f #=> \"many\"\n\n\n","format":"text/rdoc"},"/COPYING.rdoc":{"!":"document","path":"COPYING.rdoc","name":"COPYING.rdoc","mtime":"2011-10-22 21:25:36 -0400","text":"= COPYRIGHT NOTICES\n\n== Paramix\n\nCopyright:: (c) 2006 Thomas Sawyer, Rubyworks\nLicense:: BSD-2-Clause\nWebsite:: http://rubyworks.github.com/paramix\n\n    Copyright 2006 Thomas Sawyer. All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions are met:\n\n       1. Redistributions of source code must retain the above copyright notice,\n          this list of conditions and the following disclaimer.\n\n       2. Redistributions in binary form must reproduce the above copyright\n          notice, this list of conditions and the following disclaimer in the\n          documentation and/or other materials provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,\n    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n    AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n    NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE,\n    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n    OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n    EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n","format":"text/rdoc"},"/lib/paramix.rb":{"!":"script","path":"lib/paramix.rb","name":"paramix.rb","mtime":"2011-10-22 21:25:36 -0400","source":"# Paramix\n# Copyright 2010 Thomas Sawyer\n# Apache 2.0 License\n\nrequire 'paramix/version'\n\n# Paramix namespace.\n#\nmodule Paramix\n\n  # = Parametric\n  #\n  # Parametric mixins provides parameters for mixin modules.\n  # Module parameters can be set at the time of inclusion \n  # or extension using Module#[] method, then parameters\n  # can be accessed via the #mixin_parameters method.\n  #\n  #   module MyMixin\n  #     include Paramix::Parametric\n  #\n  #     parameterized |params|\n  #       define_method :hello do\n  #         puts \"Hello from #{params[:name]}!\"\n  #       end\n  #     end\n  #   end\n  #\n  #   class MyClass\n  #     include MyMixin[:name => 'Ruby']\n  #   end\n  #\n  #   MyClass.new.hello   #=> 'Hello from Ruby!'\n  #\n  module Parametric\n\n    #\n    def self.included(base)\n      base.extend(Extensions)\n    end\n\n    #\n    module Extensions\n      #\n      def [](parameters={})\n        Mixin.new(self, parameters)\n      end\n\n      #\n      def parameterized(&code)\n        @code ||= []\n        if block_given?\n          @code << code\n        else\n          @code\n        end\n      end\n\n      def append_features(base)\n        return super(base) if Mixin === base || Mixin === self\n\n        base.extend(Extensions)\n\n        anc = ancestors.find{ |a| a.respond_to?(:parameterized) }\n        base.parameterized.concat(anc.parameterized)\n\n        super(base)\n      end\n\n      #\n      def extend_object(base)\n        return super(base) if Mixin === base || Mixin === self\n\n        base.extend(Extensions)\n\n        anc = ancestors.find{ |a| a.respond_to?(:parameterized) }\n        base.parameterized.concat(anc.parameterized)\n\n        super(base)\n      end\n\n    end\n\n    # An instance of the Mixin module class is what is porduced\n    # when parameters are applied to a parametric module.\n    #\n    class Mixin < Module\n\n      def initialize(base, parameters)\n        include(base)\n        #base.append_features(self)\n        base.parameterized.each do |code|\n          instance_exec(parameters, &code)\n        end\n        #base.parameterized.clear\n      end\n\n      #\n      def public(name, &code)\n        define_method(name, &code)\n        super(name)\n      end\n\n      #\n      def private(name, &code)\n        define_method(name, &code)\n        super(name)\n      end\n\n      #\n      def protected(name, &code)\n        define_method(name, &code)\n        super(name)\n      end\n\n    end\n\n  end\n\nend\n","language":"text/x-ruby"},"/lib/paramix/version.rb":{"!":"script","path":"lib/paramix/version.rb","name":"version.rb","mtime":"2011-10-22 21:25:36 -0400","source":"module Paramix\n  VERSION = \"2.0.0\"  #:erb: VERSION = \"<%= version %>\"\nend\n","language":"text/x-ruby"}}
